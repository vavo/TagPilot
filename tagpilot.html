<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TagPilot ✈️</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.js"></script>
    <script src="config.js"></script> <!-- Loads the API key from your local, untracked config file -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Simple scrollbar styling for a more modern look */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #2d3748;
        }
        ::-webkit-scrollbar-thumb {
            background: #4a5568;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #718096;
        }
        .tooltip {
            position: relative;
            display: inline-block;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 220px;
            background-color: #2d3748;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -110px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8rem;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        .spinner {
            border: 2px solid #f3f3f3;
            border-top: 2px solid #5a67d8;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Cropper.js modal background */
        .cropper-container {
            margin: auto;
        }
        
        /* Smooth transition for collapsible */
        .collapsible-content {
            transition: max-height 0.3s ease-out;
            max-height: 0;
            overflow: hidden;
        }
        .collapsible-content.expanded {
            max-height: 1000px; /* Arbitrary large height for transition */
            overflow-y: auto;
        }
        .rotate-icon {
            transition: transform 0.3s ease;
        }
        .rotate-icon.expanded {
            transform: rotate(180deg);
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">

    <!-- Notification Element -->
    <div id="notification" class="hidden fixed top-5 right-5 bg-yellow-500 text-gray-900 py-3 px-5 rounded-lg shadow-lg z-50 transition-all duration-300 transform translate-x-full">
        <p id="notification-text"></p>
    </div>

    <div class="container mx-auto p-4 md:p-8">
        
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-white mb-2">TagPilot ✈️</h1>
            <p class="text-lg text-gray-400">Advanced LoRA Dataset Tagger</p>
        </header>

        <!-- Input Section -->
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg mb-8">
            <h2 class="text-2xl font-semibold mb-4 text-white">1. Load Your Dataset</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 max-w-4xl mx-auto">
                
                <!-- Upload Photos -->
                <div>
                    <label for="image-upload" class="w-full h-full flex flex-col items-center justify-center p-6 bg-gray-700 hover:bg-indigo-600 border-2 border-dashed border-gray-500 rounded-lg cursor-pointer transition-all">
                        <svg class="w-10 h-10 mb-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                        <span class="font-semibold">Upload Photos</span>
                        <span class="text-sm text-gray-400">Select individual image files</span>
                    </label>
                    <input id="image-upload" type="file" class="hidden" multiple accept="image/png, image/jpeg, image/webp">
                </div>

                <!-- Upload ZIP -->
                <div>
                    <label for="zip-upload" class="w-full h-full flex flex-col items-center justify-center p-6 bg-gray-700 hover:bg-indigo-600 border-2 border-dashed border-gray-500 rounded-lg cursor-pointer transition-all">
                        <svg class="w-10 h-10 mb-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
                        <span class="font-semibold">Upload ZIP Dataset</span>
                        <span class="text-sm text-gray-400">.zip file with images and .txt files</span>
                     </label>
                    <input id="zip-upload" type="file" class="hidden" accept=".zip">
                </div>
            </div>
        </div>

        <!-- Action Bar & Tagger Section -->
        <div id="tagger-section" class="hidden">
            <div class="bg-gray-800 p-4 rounded-lg shadow-lg mb-6 flex flex-col gap-4">
                <div class="flex flex-col sm:flex-row justify-between items-center gap-4 flex-wrap">
                    <h2 class="text-2xl font-semibold text-white">2. Edit Tags</h2>
                    <div class="flex items-center gap-4 flex-wrap justify-center w-full sm:w-auto">
                        <button id="reset-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition-colors shadow-md">
                            Reset All
                        </button>
                        
                        <button id="clear-tags-button" class="bg-orange-600 hover:bg-orange-700 text-white font-bold py-2 px-4 rounded-lg transition-colors shadow-md">
                            Clear Tags/Captions
                        </button>

                        <!-- Trigger Word Input -->
                        <div class="relative flex items-center">
                            <span class="absolute left-3 text-gray-400 text-sm">Trigger Word:</span>
                            <input type="text" id="trigger-word-input" placeholder="e.g. ohwx man" class="bg-gray-700 border border-gray-600 rounded-md py-2 pl-24 pr-3 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 w-40 sm:w-48">
                        </div>

                        <!-- Dataset Name Input (For export filename) -->
                        <div class="relative flex items-center">
                            <span class="absolute left-3 text-gray-400 text-sm">Dataset Name:</span>
                            <input type="text" id="dataset-name-input" placeholder="filename" class="bg-gray-700 border border-gray-600 rounded-md py-2 pl-28 pr-3 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 w-40 sm:w-48">
                        </div>

                        <button id="tag-all-button" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded-lg transition-colors shadow-md">Tag All</button>
                        <button id="caption-all-button" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition-colors shadow-md">Caption All</button>
                        <button id="export-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition-colors shadow-md">
                            Export as ZIP
                        </button>
                    </div>
                </div>
            </div>

            <!-- Tag Viewer (Replacing simple summary) -->
            <div id="tag-viewer-section" class="bg-gray-800 rounded-lg shadow-lg mb-6 overflow-hidden hidden">
                <div id="tag-viewer-header" class="p-4 bg-gray-750 flex justify-between items-center cursor-pointer hover:bg-gray-700 transition-colors border-b border-gray-700">
                    <div class="flex items-center gap-3">
                        <h3 class="text-lg font-semibold text-white">Tag Viewer</h3>
                        <span id="total-tags-badge" class="bg-indigo-900 text-indigo-200 text-xs px-2 py-1 rounded-full font-mono">0 tags</span>
                    </div>
                    <svg id="tag-viewer-arrow" class="w-5 h-5 text-gray-400 rotate-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
                <div id="tag-viewer-content" class="collapsible-content bg-gray-800">
                    <div id="tag-viewer-list" class="p-4 flex flex-wrap gap-2">
                        <!-- Tag pills will be injected here -->
                    </div>
                </div>
            </div>

            <!-- Image Grid -->
            <div id="image-grid" class="grid grid-cols-1 gap-6">
                <!-- Image cards will be dynamically inserted here -->
            </div>
             <div id="placeholder" class="text-center py-20 bg-gray-800 rounded-lg">
                <svg class="mx-auto h-12 w-12 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
                    <path vector-effect="non-scaling-stroke" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 13h6m-3-3v6m-9 1V7a2 2 0 012-2h6l2 2h6a2 2 0 01-2 2H5a2 2 0 01-2-2z" />
                </svg>
                <h3 class="mt-2 text-sm font-medium text-gray-300">No images loaded</h3>
                <p class="mt-1 text-sm text-gray-500">Upload some photos or a ZIP file to get started.</p>
            </div>
        </div>

        <!-- Loader Overlay -->
        <div id="loader" class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50">
            <div class="flex flex-col items-center">
                 <svg class="animate-spin h-10 w-10 text-white mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <p id="loader-text" class="text-white text-lg">Processing ZIP file...</p>
            </div>
        </div>

        <!-- Tag Settings Modal -->
        <div id="tag-settings-modal" class="hidden fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 p-4">
            <div class="bg-gray-800 rounded-lg shadow-xl max-w-md w-full p-6 border border-gray-700">
                
                <!-- Configuration View -->
                <div id="tag-settings-config">
                    <h3 class="text-xl font-bold text-white mb-4">Tagging Settings</h3>
                    
                    <div class="mb-4">
                        <label class="block text-gray-400 text-sm mb-2">Max number of tags per image</label>
                        <input type="number" id="setting-max-tags" value="30" min="1" max="100" class="w-full bg-gray-900 border border-gray-600 rounded px-3 py-2 text-white focus:outline-none focus:border-indigo-500">
                    </div>

                    <div class="mb-6">
                        <button id="toggle-tag-prompt-btn" class="text-sm text-indigo-400 hover:text-indigo-300 underline mb-2 focus:outline-none">
                            Edit System Prompt
                        </button>
                        <textarea id="tag-system-prompt"
                                  class="hidden w-full h-32 bg-gray-900 border border-gray-600 rounded p-2 text-xs text-gray-300 focus:outline-none focus:border-indigo-500"></textarea>
                    </div>

                    <div class="mb-6">
                        <label class="block text-gray-400 text-sm mb-2">If tags exist:</label>
                        <div class="space-y-2">
                            <label class="flex items-center space-x-3 cursor-pointer">
                                <input type="radio" name="tag-mode" value="ignore" checked class="form-radio text-indigo-600 h-4 w-4 bg-gray-900 border-gray-600 focus:ring-indigo-500">
                                <span class="text-gray-300">Ignore (Skip already tagged images)</span>
                            </label>
                            <label class="flex items-center space-x-3 cursor-pointer">
                                <input type="radio" name="tag-mode" value="append" class="form-radio text-indigo-600 h-4 w-4 bg-gray-900 border-gray-600 focus:ring-indigo-500">
                                <span class="text-gray-300">Append (Add new to existing)</span>
                            </label>
                            <label class="flex items-center space-x-3 cursor-pointer">
                                <input type="radio" name="tag-mode" value="overwrite" class="form-radio text-indigo-600 h-4 w-4 bg-gray-900 border-gray-600 focus:ring-indigo-500">
                                <span class="text-gray-300">Overwrite (Replace existing)</span>
                            </label>
                        </div>
                    </div>

                    <div class="flex justify-end gap-3">
                        <button id="cancel-tagging-btn" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 text-white rounded transition-colors">Cancel</button>
                        <button id="start-tagging-btn" class="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 text-white font-bold rounded transition-colors">Start</button>
                    </div>
                </div>

                <!-- Progress View -->
                <div id="tag-settings-progress" class="hidden text-center">
                    <h3 class="text-xl font-bold text-white mb-2">Auto-Tagging in Progress...</h3>
                    <p class="text-gray-400 mb-4">Please wait while TagPilot processes your images.</p>
                    
                    <div class="w-full bg-gray-700 rounded-full h-4 mb-2 overflow-hidden">
                        <div id="tag-progress-bar" class="bg-teal-500 h-4 rounded-full transition-all duration-300" style="width: 0%"></div>
                    </div>
                    <p id="tag-progress-text" class="text-sm text-gray-300 mb-6">0 / 0</p>

                    <button id="stop-tagging-btn" class="px-6 py-2 bg-red-600 hover:bg-red-500 text-white font-bold rounded transition-colors">Stop</button>
                </div>

            </div>
        </div>

        <!-- Caption Settings Modal -->
        <div id="caption-settings-modal" class="hidden fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 p-4">
            <div class="bg-gray-800 rounded-lg shadow-xl max-w-md w-full p-6 border border-gray-700">
                
                <!-- Configuration View -->
                <div id="caption-settings-config">
                    <h3 class="text-xl font-bold text-white mb-4">Caption Settings</h3>
                    
                    <div class="mb-4">
                        <label class="block text-gray-400 text-sm mb-2">Max caption length (words)</label>
                        <input type="number" id="setting-max-caption-len" value="50" min="5" max="200" class="w-full bg-gray-900 border border-gray-600 rounded px-3 py-2 text-white focus:outline-none focus:border-purple-500">
                    </div>

                    <div class="mb-4">
                        <label class="block text-gray-400 text-sm mb-2">If text exists:</label>
                        <div class="space-y-2">
                            <label class="flex items-center space-x-3 cursor-pointer">
                                <input type="radio" name="caption-mode" value="ignore" checked class="form-radio text-purple-600 h-4 w-4 bg-gray-900 border-gray-600 focus:ring-purple-500">
                                <span class="text-gray-300">Ignore (Skip)</span>
                            </label>
                            <label class="flex items-center space-x-3 cursor-pointer">
                                <input type="radio" name="caption-mode" value="append" class="form-radio text-purple-600 h-4 w-4 bg-gray-900 border-gray-600 focus:ring-purple-500">
                                <span class="text-gray-300">Append (Add to end)</span>
                            </label>
                            <label class="flex items-center space-x-3 cursor-pointer">
                                <input type="radio" name="caption-mode" value="overwrite" class="form-radio text-purple-600 h-4 w-4 bg-gray-900 border-gray-600 focus:ring-purple-500">
                                <span class="text-gray-300">Overwrite (Replace)</span>
                            </label>
                        </div>
                    </div>

                    <div class="mb-6">
                        <button id="toggle-caption-prompt-btn" class="text-sm text-purple-400 hover:text-purple-300 underline mb-2 focus:outline-none">Edit System Prompt</button>
                        <textarea id="caption-system-prompt" class="hidden w-full h-32 bg-gray-900 border border-gray-600 rounded p-2 text-xs text-gray-300 focus:outline-none focus:border-purple-500"></textarea>
                    </div>

                    <div class="flex justify-end gap-3">
                        <button id="cancel-captioning-btn" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 text-white rounded transition-colors">Cancel</button>
                        <button id="start-captioning-btn" class="px-4 py-2 bg-purple-600 hover:bg-purple-500 text-white font-bold rounded transition-colors">Start</button>
                    </div>
                </div>

                <!-- Progress View -->
                <div id="caption-settings-progress" class="hidden text-center">
                    <h3 class="text-xl font-bold text-white mb-2">Auto-Captioning...</h3>
                    <p class="text-gray-400 mb-4">TagPilot is writing descriptions for your images.</p>
                    
                    <div class="w-full bg-gray-700 rounded-full h-4 mb-2 overflow-hidden">
                        <div id="caption-progress-bar" class="bg-purple-500 h-4 rounded-full transition-all duration-300" style="width: 0%"></div>
                    </div>
                    <p id="caption-progress-text" class="text-sm text-gray-300 mb-6">0 / 0</p>

                    <button id="stop-captioning-btn" class="px-6 py-2 bg-red-600 hover:bg-red-500 text-white font-bold rounded transition-colors">Stop</button>
                </div>

            </div>
        </div>

        <!-- Image Preview Modal -->
        <div id="preview-modal" class="hidden fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 p-4">
            <img id="preview-image" src="" class="max-w-full max-h-full object-contain rounded-lg">
            <button id="preview-close" class="absolute top-4 right-4 text-white text-4xl font-bold">&times;</button>
        </div>

        <!-- Cropper Modal -->
        <div id="crop-modal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-90 flex flex-col items-center justify-center z-50 p-4">
            <div class="w-full max-w-4xl h-4/5">
                <img id="crop-image" src="" class="max-w-full max-h-full">
            </div>
            <div class="mt-4 flex gap-4">
                <button id="crop-save" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-6 rounded-lg">Save Crop</button>
                <button id="crop-cancel" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-6 rounded-lg">Cancel</button>
            </div>
        </div>

    </div>

    <script>
        // DOM element references
        const imageUpload = document.getElementById('image-upload');
        const zipUpload = document.getElementById('zip-upload');
        const imageGrid = document.getElementById('image-grid');
        const placeholder = document.getElementById('placeholder');
        const taggerSection = document.getElementById('tagger-section');
        const exportButton = document.getElementById('export-button');
        const resetButton = document.getElementById('reset-button');
        const clearTagsButton = document.getElementById('clear-tags-button');
        const tagAllButton = document.getElementById('tag-all-button');
        const captionAllButton = document.getElementById('caption-all-button'); 
        const datasetNameInput = document.getElementById('dataset-name-input');
        const triggerWordInput = document.getElementById('trigger-word-input');
        
        const loader = document.getElementById('loader');
        const loaderText = document.getElementById('loader-text');
        const previewModal = document.getElementById('preview-modal');
        const previewImage = document.getElementById('preview-image');
        const previewClose = document.getElementById('preview-close');
        const notification = document.getElementById('notification');
        const notificationText = document.getElementById('notification-text');
        
        // Tag Viewer References
        const tagViewerSection = document.getElementById('tag-viewer-section');
        const tagViewerHeader = document.getElementById('tag-viewer-header');
        const tagViewerContent = document.getElementById('tag-viewer-content');
        const tagViewerList = document.getElementById('tag-viewer-list');
        const tagViewerArrow = document.getElementById('tag-viewer-arrow');
        const totalTagsBadge = document.getElementById('total-tags-badge');

        // Tag Settings Modal References
        const tagSettingsModal = document.getElementById('tag-settings-modal');
        const tagSettingsConfig = document.getElementById('tag-settings-config');
        const tagSettingsProgress = document.getElementById('tag-settings-progress');
        const startTaggingBtn = document.getElementById('start-tagging-btn');
        const cancelTaggingBtn = document.getElementById('cancel-tagging-btn');
        const stopTaggingBtn = document.getElementById('stop-tagging-btn');
        const settingMaxTags = document.getElementById('setting-max-tags');
        const tagProgressBar = document.getElementById('tag-progress-bar');
        const tagProgressText = document.getElementById('tag-progress-text');
        const toggleTagPromptBtn = document.getElementById('toggle-tag-prompt-btn');
        const tagSystemPrompt = document.getElementById('tag-system-prompt');

        // Caption Settings Modal References
        const captionSettingsModal = document.getElementById('caption-settings-modal');
        const captionSettingsConfig = document.getElementById('caption-settings-config');
        const captionSettingsProgress = document.getElementById('caption-settings-progress');
        const startCaptioningBtn = document.getElementById('start-captioning-btn');
        const cancelCaptioningBtn = document.getElementById('cancel-captioning-btn');
        const stopCaptioningBtn = document.getElementById('stop-captioning-btn');
        const settingMaxCaptionLen = document.getElementById('setting-max-caption-len');
        const captionProgressBar = document.getElementById('caption-progress-bar');
        const captionProgressText = document.getElementById('caption-progress-text');
        const toggleCaptionPromptBtn = document.getElementById('toggle-caption-prompt-btn');
        const captionSystemPrompt = document.getElementById('caption-system-prompt');

        // Cropper elements
        const cropModal = document.getElementById('crop-modal');
        const cropImage = document.getElementById('crop-image');
        const cropSaveButton = document.getElementById('crop-save');
        const cropCancelButton = document.getElementById('crop-cancel');
        let cropper = null;
        let currentCropIndex = -1;

        // Global state
        // dataset array items now have: { file, tags, type: 'tags'|'caption' }
        let dataset = []; 
        let currentTriggerWord = ""; 
        let isBatchProcessing = false; 

        // Default Tag Prompt
        const DEFAULT_TAG_PROMPT = `You are an expert for creating photorealistic AI training datasets. Your task is to generate descriptive tags for the provided image for the purpose of SDXL lora training using kohya_ss.
Follow these rules strictly:
1.  **Focus on Unique Features:** Prioritize tags that describe the subject's unique identity, specific clothing (e.g., 'blue denim jacket', not just 'jacket'), hairstyle and color, distinct facial features (e.g., 'freckles', 'defined jawline'), and overall style cues (e.g., 'goth style', 'business casual').
2.  **Avoid Noise:** Do NOT use generic, low-impact tags like 'solo', '1girl', 'looking at viewer', 'realistic', 'photorealistic'.
3.  **Prioritize Impact:** List the most descriptive and important tags first.
4.  **Balance Character and Context:** Aim for approximately two-thirds of the tags describing the character (person, clothing, hair, accessories) and one-third describing the background, composition, and lighting (e.g., 'outdoors', 'city street at night', 'soft lighting').
5.  **Be Concise and Specific:** Avoid redundant tags. For example, use 'blue eyes' instead of 'blue color, eyes'.

The final output MUST be a comma-separated list of tags.`;

        // Default Caption Prompt
        const DEFAULT_CAPTION_PROMPT = `You are an expert for creating photorealistic AI training datasets. Your task is to generate descriptive caption for the provided image for the purpose of Lora training using tools like kohya_ss, OneTrainer or diffusion pipes. Follow these rules strictly:

1. Information sufficiency: Captions should include all meaningful content and be comprehensive, especially for complex scenes that may be overlooked by general captions.
2. Minimal redundancy: Captions should be concise and avoid unnecessary repetition of information.
3. Human comprehensibility: Captions should be phrased naturally using correct spelling, grammar, and punctuation to be easily understood by humans.
4. Grounded descriptions: For more specific tasks, provide region-specific captions that describe a particular area of the image defined by a bounding box, rather than just the general scene.
5. Variety: Ensure a diverse set of captions for each image, including both general descriptions and more detailed ones, to provide richer training data.

Expected outcome is a human-readable continuous text consisting of several sentences without the use of numbering or bullet points.`;

        // Initialize system prompt textareas
        tagSystemPrompt.value = DEFAULT_TAG_PROMPT;
        captionSystemPrompt.value = DEFAULT_CAPTION_PROMPT;

        // --- Event Listeners ---
        imageUpload.addEventListener('change', handleImageUpload);
        zipUpload.addEventListener('change', handleZipUpload);
        exportButton.addEventListener('click', handleExport);
        resetButton.addEventListener('click', handleReset);
        clearTagsButton.addEventListener('click', handleClearTags); 
        tagAllButton.addEventListener('click', openTagSettings); 
        captionAllButton.addEventListener('click', openCaptionSettings); 
        
        // Tag Settings Listeners
        startTaggingBtn.addEventListener('click', startBatchTagging);
        cancelTaggingBtn.addEventListener('click', closeTagSettings);
        stopTaggingBtn.addEventListener('click', stopBatchProcessing);

        toggleTagPromptBtn.addEventListener('click', () => {
            tagSystemPrompt.classList.toggle('hidden');
        });

        // Caption Settings Listeners
        startCaptioningBtn.addEventListener('click', startBatchCaptioning);
        cancelCaptioningBtn.addEventListener('click', closeCaptionSettings);
        stopCaptioningBtn.addEventListener('click', stopBatchProcessing);
        toggleCaptionPromptBtn.addEventListener('click', () => {
            captionSystemPrompt.classList.toggle('hidden');
        });

        previewClose.addEventListener('click', hidePreview);
        triggerWordInput.addEventListener('input', handleTriggerWordChange);

        tagViewerHeader.addEventListener('click', () => {
            tagViewerContent.classList.toggle('expanded');
            tagViewerArrow.classList.toggle('expanded');
        });

        previewModal.addEventListener('click', (e) => {
            if (e.target === previewModal) hidePreview();
        });
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (!previewModal.classList.contains('hidden')) hidePreview();
                if (!cropModal.classList.contains('hidden')) cancelCrop();
                if (!tagSettingsModal.classList.contains('hidden') && !isBatchProcessing) closeTagSettings();
                if (!captionSettingsModal.classList.contains('hidden') && !isBatchProcessing) closeCaptionSettings();
            }
        });
        
        cropSaveButton.addEventListener('click', saveCrop);
        cropCancelButton.addEventListener('click', cancelCrop);


        // --- Tagging Modal Logic ---

        function openTagSettings() {
            if (dataset.length === 0) {
                showNotification("No images loaded to tag.", 3000);
                return;
            }
            tagSettingsConfig.classList.remove('hidden');
            tagSettingsProgress.classList.add('hidden');
            tagSettingsModal.classList.remove('hidden');
        }

        function closeTagSettings() {
            tagSettingsModal.classList.add('hidden');
        }

        function openCaptionSettings() {
            if (dataset.length === 0) {
                showNotification("No images loaded to caption.", 3000);
                return;
            }
            captionSettingsConfig.classList.remove('hidden');
            captionSettingsProgress.classList.add('hidden');
            captionSettingsModal.classList.remove('hidden');
        }

        function closeCaptionSettings() {
            captionSettingsModal.classList.add('hidden');
        }

        function stopBatchProcessing() {
            isBatchProcessing = false;
            stopTaggingBtn.textContent = "Stopping...";
            stopTaggingBtn.disabled = true;
            stopCaptioningBtn.textContent = "Stopping...";
            stopCaptioningBtn.disabled = true;
        }

        async function startBatchTagging() {
            if (typeof userApiKey === 'undefined' || !userApiKey) {
                showNotification("API Key is missing. Check config.js", 4000, true);
                return;
            }

            const maxTags = parseInt(settingMaxTags.value, 10) || 30;
            const mode = document.querySelector('input[name="tag-mode"]:checked').value;
            const customTagPrompt = tagSystemPrompt.value.trim() || DEFAULT_TAG_PROMPT;

            tagSettingsConfig.classList.add('hidden');
            tagSettingsProgress.classList.remove('hidden');
            stopTaggingBtn.textContent = "Stop";
            stopTaggingBtn.disabled = false;
            isBatchProcessing = true;

            let processed = 0;
            const total = dataset.length;
            updateProgress(0, total, tagProgressBar, tagProgressText);
            
            for (let i = 0; i < total; i++) {
                if (!isBatchProcessing) break;

                const item = dataset[i];
                const currentTags = item.tags.trim();
                
                let shouldTag = false;
                if (mode === 'overwrite') shouldTag = true;
                else if (mode === 'append') shouldTag = true; 
                else if (mode === 'ignore') {
                    const hasTags = currentTags.length > 0 && currentTags !== currentTriggerWord;
                    if (!hasTags) shouldTag = true;
                }

                if (shouldTag) {
                    try {
                        const file = item.file;
                        const base64Data = await imageToBase64(file);
                        const newTagsString = await generateTagsWithGemini(base64Data, file.type, customTagPrompt);

                        if (newTagsString) {
                            let newTags = newTagsString.split(',').map(t => t.trim()).filter(Boolean);
                            let finalTags = [];

                            if (mode === 'overwrite') {
                                finalTags = newTags;
                            } else {
                                const existing = currentTags.split(',').map(t => t.trim()).filter(Boolean);
                                finalTags = [...existing, ...newTags];
                            }

                            finalTags = [...new Set(finalTags)];

                            if (currentTriggerWord) {
                                finalTags = finalTags.filter(t => t !== currentTriggerWord);
                                finalTags.unshift(currentTriggerWord);
                            }

                            if (finalTags.length > maxTags) {
                                finalTags = finalTags.slice(0, maxTags);
                            }

                            // Update data
                            item.tags = finalTags.join(', ');
                            item.type = 'tags'; // Set Type to Tags

                            const tagAreaWrapper = document.querySelector(`.tag-area-wrapper[data-index='${i}']`);
                            if (tagAreaWrapper) renderTagsInCard(tagAreaWrapper, i);
                        }
                    } catch (e) {
                        console.error(`Error tagging image ${i}`, e);
                    }
                }

                processed++;
                updateProgress(processed, total, tagProgressBar, tagProgressText);
            }

            renderTagViewer(); 
            isBatchProcessing = false;
            closeTagSettings();
            showNotification(processed === total ? "Tagging Complete!" : "Tagging Stopped.");
        }

        async function startBatchCaptioning() {
            if (typeof userApiKey === 'undefined' || !userApiKey) {
                showNotification("API Key is missing. Check config.js", 4000, true);
                return;
            }

            const maxLength = parseInt(settingMaxCaptionLen.value, 10) || 50;
            const mode = document.querySelector('input[name="caption-mode"]:checked').value;
            const customPrompt = captionSystemPrompt.value.trim() || DEFAULT_CAPTION_PROMPT;

            captionSettingsConfig.classList.add('hidden');
            captionSettingsProgress.classList.remove('hidden');
            stopCaptioningBtn.textContent = "Stop";
            stopCaptioningBtn.disabled = false;
            isBatchProcessing = true;

            let processed = 0;
            const total = dataset.length;
            updateProgress(0, total, captionProgressBar, captionProgressText);
            
            for (let i = 0; i < total; i++) {
                if (!isBatchProcessing) break;

                const item = dataset[i];
                const currentText = item.tags.trim();
                
                let shouldCaption = false;
                if (mode === 'overwrite') shouldCaption = true;
                else if (mode === 'append') shouldCaption = true;
                else if (mode === 'ignore') {
                    if (currentText.length === 0 || currentText === currentTriggerWord) shouldCaption = true;
                }

                if (shouldCaption) {
                    try {
                        const file = item.file;
                        const base64Data = await imageToBase64(file);
                        const caption = await generateCaptionWithGemini(base64Data, file.type, customPrompt, maxLength);

                        if (caption) {
                            let finalText = "";
                            if (mode === 'overwrite') {
                                finalText = caption;
                            } else {
                                // Append with a space for captions
                                finalText = currentText ? currentText + " " + caption : caption;
                            }
                            
                            if (currentTriggerWord && !finalText.startsWith(currentTriggerWord)) {
                                finalText = currentTriggerWord + ", " + finalText;
                            }

                            dataset[i].tags = finalText;
                            dataset[i].type = 'caption'; // Set Type to Caption
                            
                            const tagAreaWrapper = document.querySelector(`.tag-area-wrapper[data-index='${i}']`);
                            if (tagAreaWrapper) renderTagsInCard(tagAreaWrapper, i);
                        }
                    } catch (e) {
                        console.error(`Error captioning image ${i}`, e);
                    }
                }

                processed++;
                updateProgress(processed, total, captionProgressBar, captionProgressText);
            }

            renderTagViewer();
            isBatchProcessing = false;
            closeCaptionSettings();
            showNotification(processed === total ? "Captioning Complete!" : "Captioning Stopped.");
        }

        function updateProgress(current, total, barElement, textElement) {
            const percent = Math.round((current / total) * 100);
            barElement.style.width = `${percent}%`;
            textElement.textContent = `${current} / ${total}`;
        }


        // --- Core Logic ---

        function handleTriggerWordChange(e) {
            const newTrigger = e.target.value.trim();
            dataset.forEach((item, index) => {
                let currentText = item.tags.trim();
                
                // Remove old trigger word from start
                if (currentTriggerWord && currentText.startsWith(currentTriggerWord)) {
                    // Remove trigger word and following comma/space if present
                    currentText = currentText.substring(currentTriggerWord.length).trim();
                    if (currentText.startsWith(',')) currentText = currentText.substring(1).trim();
                }
                
                // Add new trigger word
                if (newTrigger) {
                    if (currentText) {
                        currentText = newTrigger + ", " + currentText;
                    } else {
                        currentText = newTrigger;
                    }
                }
                
                item.tags = currentText;
            });
            currentTriggerWord = newTrigger;
            renderTagUpdates();
        }

        function renderTagUpdates() {
            dataset.forEach((item, index) => {
                const tagAreaWrapper = document.querySelector(`.tag-area-wrapper[data-index='${index}']`);
                if (tagAreaWrapper) {
                    renderTagsInCard(tagAreaWrapper, index);
                }
            });
            renderTagViewer();
        }

        async function handleImageUpload(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;
            showLoader('Processing & checking for duplicates...');

            const existingHashes = new Set(await Promise.all(dataset.map(item => calculateFileHash(item.file))));
            const newDatasetItems = [];
            const duplicatesFound = [];

            for (const file of files) {
                const hash = await calculateFileHash(file);
                if (existingHashes.has(hash)) {
                    duplicatesFound.push(file.name);
                    continue;
                }

                let finalFile = file;
                if (file.name.toLowerCase().endsWith('.jpeg')) {
                    const newName = file.name.slice(0, -5) + '.jpg';
                    finalFile = new File([file], newName, { type: 'image/jpeg' });
                }
                
                let initialTags = currentTriggerWord ? currentTriggerWord : "";
                // Default type to 'tags'
                newDatasetItems.push({ file: finalFile, tags: initialTags, type: 'tags' });
                existingHashes.add(hash); 
            }
            
            dataset.push(...newDatasetItems);
            hideLoader();

            if (duplicatesFound.length > 0) {
                showNotification(`Skipped ${duplicatesFound.length} duplicate image(s).`);
            }
            render();
        }

        async function handleZipUpload(event) {
            const zipFile = event.target.files[0];
            if (!zipFile) return;

            showLoader('Processing ZIP & checking for duplicates...');
            
            try {
                const jszip = new JSZip();
                const zip = await jszip.loadAsync(zipFile);
                
                const imageFiles = {};
                const textFiles = {};
                const imageExtensions = ['.jpg', '.jpeg', '.png', '.webp'];

                for (const filename in zip.files) {
                    if (zip.files[filename].dir) continue;
                    const lowerFilename = filename.toLowerCase();
                    if (imageExtensions.some(ext => lowerFilename.endsWith(ext))) {
                        const baseName = filename.substring(0, filename.lastIndexOf('.'));
                        imageFiles[baseName] = { file: zip.files[filename], originalName: filename };
                    } else if (lowerFilename.endsWith('.txt')) {
                        const baseName = filename.substring(0, filename.lastIndexOf('.'));
                        textFiles[baseName] = zip.files[filename];
                    }
                }

                const existingHashes = new Set(await Promise.all(dataset.map(item => calculateFileHash(item.file))));
                const newDatasetItems = [];
                const duplicatesFound = [];

                for (const baseName in imageFiles) {
                    const { file: imageZipObject, originalName } = imageFiles[baseName];
                    const imageBlob = await imageZipObject.async('blob');
                    
                    let finalName = originalName;
                    if (originalName.toLowerCase().endsWith('.jpeg')) {
                        finalName = originalName.slice(0, -5) + '.jpg';
                    }
                    const imageFile = new File([imageBlob], finalName, { type: imageBlob.type });

                    const hash = await calculateFileHash(imageFile);
                    if (existingHashes.has(hash)) {
                        duplicatesFound.push(originalName);
                        continue;
                    }

                    let tags = '';
                    if (textFiles[baseName]) {
                        tags = await textFiles[baseName].async('string');
                        tags = tags.trim();
                    }

                    if (currentTriggerWord) {
                        if (!tags.startsWith(currentTriggerWord)) {
                            tags = tags ? currentTriggerWord + ", " + tags : currentTriggerWord;
                        }
                    }

                    // For existing zip, assume 'tags' type default, or maybe check for periods? Default safe is 'tags'.
                    newDatasetItems.push({ file: imageFile, tags: tags, type: 'tags' });
                    existingHashes.add(hash);
                }
                
                dataset.push(...newDatasetItems);
                render();

                if (duplicatesFound.length > 0) {
                    showNotification(`Skipped ${duplicatesFound.length} duplicate image(s) from ZIP.`);
                }

            } catch (error) {
                console.error("Error processing ZIP file:", error);
                showNotification("Error processing ZIP. See console for details.", 5000, true);
            } finally {
                hideLoader();
            }
        }

        function handleReset() {
            dataset = [];
            imageUpload.value = '';
            zipUpload.value = '';
            datasetNameInput.value = '';
            triggerWordInput.value = '';
            currentTriggerWord = '';
            render();
        }

        function handleClearTags() {
            if (!confirm("Are you sure you want to clear tags/captions from all images? Images will remain loaded.")) return;
            
            dataset.forEach(item => {
                // If trigger word is set, keep it, otherwise clear all
                if (currentTriggerWord) {
                    item.tags = currentTriggerWord;
                } else {
                    item.tags = "";
                }
                // Reset type to default
                item.type = 'tags';
            });
            
            renderTagUpdates();
            showNotification("All tags cleared.");
        }

        function removeImage(indexToRemove) {
            dataset.splice(indexToRemove, 1);
            render();
        }

        function updateTags(index, tagsArray, shouldRenderSummary = true) {
            if (dataset[index]) {
                dataset[index].tags = tagsArray.join(', ');
            }
            if (shouldRenderSummary) renderTagViewer();
        }
        
        function deleteTagGlobally(tagToDelete) {
            if (!confirm(`Are you sure you want to delete the tag "${tagToDelete}" from all images?`)) return;

            dataset.forEach((item, index) => {
                if (item.type === 'caption') return; // Skip captions for global tag delete
                let tags = item.tags.split(',').map(t => t.trim()).filter(Boolean);
                if (tags.includes(tagToDelete)) {
                    tags = tags.filter(t => t !== tagToDelete);
                    item.tags = tags.join(', ');
                }
            });
            renderTagUpdates(); 
            showNotification(`Deleted tag "${tagToDelete}" from dataset.`);
        }

        function toggleCardType(index) {
            const item = dataset[index];
            item.type = item.type === 'caption' ? 'tags' : 'caption';
            const tagAreaWrapper = document.querySelector(`.tag-area-wrapper[data-index='${index}']`);
            if (tagAreaWrapper) renderTagsInCard(tagAreaWrapper, index);
        }

        function render() {
            imageGrid.innerHTML = '';

            if (dataset.length > 0) {
                taggerSection.classList.remove('hidden');
                tagViewerSection.classList.remove('hidden');
                placeholder.classList.add('hidden');
                imageGrid.classList.remove('hidden');

                dataset.forEach((item, index) => {
                    const card = document.createElement('div');
                    card.className = 'bg-gray-800 rounded-lg shadow-md overflow-hidden flex h-72 items-center';
                    card.id = `card-${index}`;

                    const imageUrl = URL.createObjectURL(item.file);

                    card.innerHTML = `
                        <div class="p-4 h-full flex items-center justify-center">
                            <span class="text-2xl font-bold text-gray-500">${index + 1}</span>
                        </div>
                        <div class="w-2/5 flex-shrink-0 cursor-pointer thumbnail-container h-full">
                            <img src="${imageUrl}" alt="${item.file.name}" class="w-full h-full object-cover">
                        </div>
                        <div class="p-4 flex flex-col flex-grow min-w-0 h-full">
                            <div class="flex justify-between items-center mb-2">
                                <p class="text-xs text-gray-400" id="resolution-${index}">...</p>
                                <button class="text-xs text-gray-500 hover:text-white" title="Toggle View Mode (Tags/Text)" onclick="toggleCardType(${index})">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                                    </svg>
                                </button>
                            </div>
                            <div class="flex flex-grow gap-3 min-h-0">
                                <div class="tag-area-wrapper w-full flex-grow bg-gray-700 border border-gray-600 rounded-md p-2 flex flex-wrap items-start content-start gap-2 overflow-y-auto" data-index="${index}">
                                </div>
                                <div class="flex flex-col gap-2 flex-shrink-0">
                                    <button class="crop-btn w-full flex items-center justify-center gap-2 text-sm bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-3 rounded-md transition-colors" data-index="${index}">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                                            <path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />
                                            <path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.022 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd" />
                                        </svg>
                                        <span>Crop</span>
                                    </button>
                                     <button class="autotag-single-button w-full flex items-center justify-center gap-2 text-sm bg-teal-600 hover:bg-teal-700 text-white font-semibold py-2 px-3 rounded-md transition-colors" data-index="${index}">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                            <path stroke-linecap="round" stroke-linejoin="round" d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z" />
                                        </svg>
                                        <span>Tag</span>
                                    </button>
                                    <button class="caption-single-button w-full flex items-center justify-center gap-2 text-sm bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 px-3 rounded-md transition-colors" data-index="${index}">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                            <path stroke-linecap="round" stroke-linejoin="round" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z" />
                                        </svg>
                                        <span>Caption</span>
                                    </button>
                                    <button class="remove-btn w-full flex items-center justify-center gap-2 text-sm bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-3 rounded-md transition-colors" data-index="${index}">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                            <path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                        </svg>
                                        <span>Delete</span>
                                    </button>
                                </div>
                            </div>
                        </div>
                    `;

                    const resEl = card.querySelector(`#resolution-${index}`);
                    const img = new Image();
                    img.onload = () => {
                        resEl.textContent = `${img.naturalWidth} x ${img.naturalHeight}`;
                    };
                    img.src = imageUrl;
                    
                    const tagAreaWrapper = card.querySelector('.tag-area-wrapper');
                    renderTagsInCard(tagAreaWrapper, index);

                    card.querySelector('.remove-btn').addEventListener('click', (e) => removeImage(index));
                    card.querySelector('.thumbnail-container').addEventListener('click', () => showPreview(imageUrl));
                    card.querySelector('.autotag-single-button').addEventListener('click', (e) => handleAutoTag(index));
                    card.querySelector('.caption-single-button').addEventListener('click', (e) => handleSingleCaption(index)); // New
                    card.querySelector('.crop-btn').addEventListener('click', () => startCropping(index));

                    imageGrid.appendChild(card);
                });
            } else {
                taggerSection.classList.add('hidden');
                tagViewerSection.classList.add('hidden');
                placeholder.classList.remove('hidden');
                imageGrid.classList.add('hidden');
            }
            renderTagViewer();
        }
        
        function renderTagsInCard(container, index) {
            container.innerHTML = ''; 
            const item = dataset[index];
            const isCaptionMode = item.type === 'caption';

            if (isCaptionMode) {
                // Render Text Area for Caption Mode
                const textarea = document.createElement('textarea');
                textarea.className = 'w-full h-full bg-gray-900 text-gray-200 text-sm border-none outline-none resize-none p-2 rounded focus:ring-1 focus:ring-indigo-500';
                textarea.placeholder = "Enter caption...";
                textarea.value = item.tags;
                textarea.addEventListener('input', (e) => {
                    item.tags = e.target.value;
                });
                container.appendChild(textarea);
                return;
            }
            
            // Render Tags (Pills) with 'x' to remove
            const tags = item.tags ? item.tags.split(',').map(t => t.trim()).filter(Boolean) : [];

            tags.forEach((tag, i) => {
                const tagEl = document.createElement('div');
                const isTrigger = i === 0 && currentTriggerWord && tag === currentTriggerWord;
                const bgClass = isTrigger ? 'bg-purple-600' : 'bg-indigo-500';
                
                tagEl.className = `flex items-center ${bgClass} text-white text-xs px-2 py-1 rounded-full cursor-default select-none max-w-full`;
                tagEl.innerHTML = `
                    <span class="truncate max-w-[150px]" title="${tag}">${tag}</span>
                    <button class="ml-2 text-indigo-100 hover:text-white remove-tag-btn font-bold flex-shrink-0">&times;</button>
                `;
                tagEl.querySelector('.remove-tag-btn').addEventListener('click', () => {
                    const newTags = tags.filter((_, idx) => idx !== i);
                    updateTags(index, newTags);
                    renderTagsInCard(container, index); 
                });
                container.appendChild(tagEl);
            });

            const inputEl = document.createElement('input');
            inputEl.type = 'text';
            inputEl.placeholder = 'Add tag...';
            inputEl.className = 'bg-transparent text-sm flex-grow p-1 focus:outline-none min-w-[80px]';
            inputEl.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ',') {
                    e.preventDefault();
                    const newTag = inputEl.value.trim();
                    if (newTag) {
                        const current = dataset[index].tags ? dataset[index].tags.split(',').map(t => t.trim()).filter(Boolean) : [];
                        // Check for duplicates before adding
                        if (!current.includes(newTag)) {
                            current.push(newTag);
                            updateTags(index, current);
                            renderTagsInCard(container, index);
                        }
                    }
                    inputEl.value = '';
                }
            });
            container.appendChild(inputEl);
        }

        function renderTagViewer() {
            if (dataset.length === 0) {
                tagViewerSection.classList.add('hidden');
                tagViewerList.innerHTML = '';
                return;
            }

            tagViewerSection.classList.remove('hidden');
            
            const tagCounts = {};
            for (const item of dataset) {
                if (item.type === 'caption') continue;

                const tags = item.tags ? item.tags.split(',').map(t => t.trim()).filter(Boolean) : [];
                for (const tag of tags) {
                    tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                }
            }

            const sortedTags = Object.entries(tagCounts).sort(([, a], [, b]) => b - a);
            totalTagsBadge.textContent = `${sortedTags.length} tags`;
            tagViewerList.innerHTML = ''; 
            
            if (sortedTags.length === 0) {
                tagViewerList.innerHTML = '<p class="text-gray-500 w-full text-center">No tags found (or all images are in caption mode).</p>';
                return;
            }

            sortedTags.forEach(([tag, count]) => {
                const pill = document.createElement('div');
                pill.className = 'flex items-center bg-gray-700 border border-gray-600 rounded-full px-3 py-1 text-sm hover:bg-gray-600 transition-colors';
                pill.innerHTML = `
                    <span class="text-gray-200 mr-2">${tag}</span>
                    <span class="bg-gray-800 text-gray-400 text-xs px-1.5 py-0.5 rounded-full mr-2">${count}</span>
                    <button class="text-gray-500 hover:text-red-400 font-bold delete-global-btn" title="Delete from all images">&times;</button>
                `;
                
                pill.querySelector('.delete-global-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteTagGlobally(tag);
                });
                
                tagViewerList.appendChild(pill);
            });
        }

        async function handleExport() {
            if (dataset.length === 0) return;
            
            const nameOfTheDataset = datasetNameInput.value.trim().replace(/[^a-zA-Z0-9_-]/g, '') || 'dataset';
            if (!nameOfTheDataset && !datasetNameInput.value) {
                datasetNameInput.focus();
                datasetNameInput.classList.add('ring-2', 'ring-red-500');
                setTimeout(() => datasetNameInput.classList.remove('ring-2', 'ring-red-500'), 2000);
            }
            
            const finalName = nameOfTheDataset || 'dataset';

            showLoader('Zipping files...');
            try {
                const zip = new JSZip();
                const folder = zip.folder(`1_${finalName}`);

                dataset.forEach((item, index) => {
                    const fileNumber = String(index + 1).padStart(3, '0');
                    const newBaseName = `${finalName}${fileNumber}`;
                    const newImageName = `${newBaseName}.jpg`;
                    const newTxtName = `${newBaseName}.txt`;
                    
                    folder.file(newImageName, item.file);
                    if (item.tags.trim() !== '') {
                        folder.file(newTxtName, item.tags);
                    }
                });

                const zipBlob = await zip.generateAsync({ type: 'blob' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(zipBlob);
                link.download = `data-${finalName}.zip`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);

            } catch (error) {
                console.error("Error exporting ZIP file:", error);
            } finally {
                hideLoader();
            }
        }

        async function handleAutoTagAll() {
            openTagSettings();
        }

        async function handleAutoTag(index) {
            const button = document.querySelector(`.autotag-single-button[data-index='${index}']`);
            if (!button) return;

            const originalContent = button.innerHTML;
            button.innerHTML = '<div class="spinner"></div>';
            button.disabled = true;

            try {
                const file = dataset[index].file;
                const base64Data = await imageToBase64(file);
                const customTagPrompt = tagSystemPrompt.value.trim() || DEFAULT_TAG_PROMPT;
                const generatedTagsString = await generateTagsWithGemini(base64Data, file.type, customTagPrompt);
                
                if (generatedTagsString) {
                    const existingTags = dataset[index].tags ? dataset[index].tags.split(',').map(t => t.trim()).filter(Boolean) : [];
                    const newTags = generatedTagsString.split(',').map(t => t.trim()).filter(Boolean);
                    
                    let combinedTags = [...new Set([...existingTags, ...newTags])];

                    if (currentTriggerWord) {
                        combinedTags = combinedTags.filter(t => t !== currentTriggerWord);
                        combinedTags.unshift(currentTriggerWord);
                    }
                    
                    if (combinedTags.length > 30) {
                        combinedTags = combinedTags.slice(0, 30);
                    }

                    updateTags(index, combinedTags);
                    dataset[index].type = 'tags'; // Force type
                    
                    const tagAreaWrapper = document.querySelector(`.tag-area-wrapper[data-index='${index}']`);
                    if (tagAreaWrapper) {
                        renderTagsInCard(tagAreaWrapper, index);
                    }
                }
            } catch (error) {
                console.error(`Failed to auto-tag image ${index}:`, error);
            } finally {
                button.innerHTML = originalContent;
                button.disabled = false;
            }
        }

        // --- Single Caption Logic ---
        async function handleSingleCaption(index) {
            const button = document.querySelector(`.caption-single-button[data-index='${index}']`);
            if (!button) return;

            const originalContent = button.innerHTML;
            button.innerHTML = '<div class="spinner"></div>';
            button.disabled = true;

            try {
                const file = dataset[index].file;
                const base64Data = await imageToBase64(file);
                // For single caption, assume default prompt and max len 75, simple append
                const caption = await generateCaptionWithGemini(base64Data, file.type, DEFAULT_CAPTION_PROMPT, 75);
                
                if (caption) {
                    let currentText = dataset[index].tags;
                    let finalText = currentText ? currentText + " " + caption : caption;
                    
                    if (currentTriggerWord && !finalText.startsWith(currentTriggerWord)) {
                        finalText = currentTriggerWord + ", " + finalText;
                    }

                    dataset[index].tags = finalText;
                    dataset[index].type = 'caption'; // Force type

                    const tagAreaWrapper = document.querySelector(`.tag-area-wrapper[data-index='${index}']`);
                    if (tagAreaWrapper) {
                        renderTagsInCard(tagAreaWrapper, index);
                    }
                }
            } catch (error) {
                console.error(`Failed to caption image ${index}:`, error);
            } finally {
                button.innerHTML = originalContent;
                button.disabled = false;
            }
        }

        function startCropping(index) {
            currentCropIndex = index;
            const file = dataset[index].file;
            const imageUrl = URL.createObjectURL(file);
            
            cropImage.src = imageUrl;
            cropModal.classList.remove('hidden');

            cropper = new Cropper(cropImage, {
                aspectRatio: NaN,
                viewMode: 1,
                background: false,
                autoCropArea: 0.8,
            });
        }

        function saveCrop() {
            if (!cropper || currentCropIndex < 0) return;

            showLoader('Cropping image...');
            const originalFile = dataset[currentCropIndex].file;

            cropper.getCroppedCanvas().toBlob(async (blob) => {
                const newFile = new File([blob], originalFile.name, { type: 'image/jpeg' });
                dataset[currentCropIndex].file = newFile;
                
                cropper.destroy();
                cropper = null;
                cropImage.src = '';
                cropModal.classList.add('hidden');
                currentCropIndex = -1;
                
                hideLoader();
                render(); 
            }, 'image/jpeg', 0.95);
        }

        function cancelCrop() {
            if (cropper) {
                cropper.destroy();
                cropper = null;
            }
            cropImage.src = '';
            cropModal.classList.add('hidden');
            currentCropIndex = -1;
        }

        function imageToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = error => reject(error);
                reader.readAsDataURL(file);
            });
        }

        async function calculateFileHash(file) {
            const buffer = await file.arrayBuffer();
            const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            return hashHex;
        }
        
        async function generateTagsWithGemini(base64ImageData, mimeType, customPrompt) {
            if (typeof userApiKey === 'undefined' || !userApiKey) {
                showNotification("API Key is missing. Please add it to config.js.", 5000, true);
                throw new Error("API Key is missing.");
            }
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${userApiKey}`;

            const systemPrompt = (customPrompt && customPrompt.trim().length > 0)
                ? customPrompt.trim()
                : DEFAULT_TAG_PROMPT;

            const payload = {
                contents: [{
                    parts: [
                        { text: systemPrompt },
                        { inlineData: { mimeType: mimeType, data: base64ImageData } }
                    ]
                }]
            };

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    throw new Error(`API request failed with status ${response.status}: ${await response.text()}`);
                }
                
                const result = await response.json();
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

                if (text) {
                    return text.trim();
                }
                return null;
            } catch (error) {
                console.error("Gemini API call failed:", error);
                return null;
            }
        }

        async function generateCaptionWithGemini(base64ImageData, mimeType, customPrompt, maxLength) {
            if (typeof userApiKey === 'undefined' || !userApiKey) {
                showNotification("API Key is missing. Please add it to config.js.", 5000, true);
                throw new Error("API Key is missing.");
            }

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${userApiKey}`;

            const finalPrompt = `${customPrompt} Keep the description strictly under ${maxLength} words.`;

            const payload = {
                contents: [{
                    parts: [
                        { text: finalPrompt },
                        { inlineData: { mimeType: mimeType, data: base64ImageData } }
                    ]
                }]
            };

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    throw new Error(`API request failed with status ${response.status}: ${await response.text()}`);
                }
                
                const result = await response.json();
                let text = result.candidates?.[0]?.content?.parts?.[0]?.text || "";

                text = text.trim();

                // HARD ENFORCED WORD LIMIT
                const words = text.split(/\s+/);
                if (words.length > maxLength) {
                    text = words.slice(0, maxLength).join(" ");
                }

                return text;

            } catch (error) {
                console.error("TagPilot Captioning API call failed:", error);
                return null;
            }
        }

        function showPreview(imageUrl) {
            previewImage.src = imageUrl;
            previewModal.classList.remove('hidden');
        }

        function hidePreview() {
            previewImage.src = '';
            previewModal.classList.add('hidden');
        }
        
        function showNotification(message, duration = 4000, isError = false) {
            notificationText.textContent = message;
            notification.classList.toggle('bg-red-600', isError);
            notification.classList.toggle('bg-yellow-500', !isError);
            notification.classList.remove('hidden', 'translate-x-full');

            setTimeout(() => {
                notification.classList.add('translate-x-full');
            }, duration);
        }

        function showLoader(message) {
            loaderText.textContent = message;
            loader.classList.remove('hidden');
        }

        function hideLoader() {
            loader.classList.add('hidden');
        }

        render();

    </script>
</body>
</html>
